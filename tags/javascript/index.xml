<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on jackieli.dev</title><link>https://www.jackieli.dev/tags/javascript/</link><description>Recent content in javascript on jackieli.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 01 Aug 2020 11:28:51 +0100</lastBuildDate><atom:link href="https://www.jackieli.dev/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC-Web interceptor</title><link>https://www.jackieli.dev/posts/grpc-web-interceptor/</link><pubDate>Sat, 01 Aug 2020 11:28:51 +0100</pubDate><guid>https://www.jackieli.dev/posts/grpc-web-interceptor/</guid><description>This was supposed to be 5 minute job, or at least it looked like it after I skimmed through the documentation
This was my first attempt:
class AuthInterceptor&amp;lt;REQ extends Request, RESP = any&amp;gt; { Intercept = class { private stream: grpcWeb.ClientReadableStream&amp;lt;RESP&amp;gt;; constructor(stream: grpcWeb.ClientReadableStream&amp;lt;RESP&amp;gt;) { this.stream = stream; } on&amp;lt;F extends Function&amp;gt;(eventType: EventType, callback: F) { if (eventType === &amp;#34;error&amp;#34;) { this.stream.on(&amp;#34;error&amp;#34;, (err: grpcWeb.Error) =&amp;gt; { if (process.env.NODE_ENV === &amp;#34;development&amp;#34;) { console.</description></item><item><title>BigInt toBytes in different languages</title><link>https://www.jackieli.dev/posts/bigint-tobytes/</link><pubDate>Fri, 24 Jul 2020 11:00:17 +0100</pubDate><guid>https://www.jackieli.dev/posts/bigint-tobytes/</guid><description>Go &amp;amp; Javascript seems to be doing the same thing on BigInt: toBytes returns the absolute value with the sign seperately. While Java returns the Two&amp;rsquo;s complement representation. It makes it just a bit trickier to get the right binary representation.
javascript $ node &amp;gt; BigInt(-257).toString(16) &amp;#39;-101&amp;#39; &amp;gt; BigInt(257).toString(16) &amp;#39;101&amp;#39; &amp;gt; It&amp;rsquo;s basically the sign plus the hex of the absolute value
Go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/big&amp;#34; ) func main() { fmt.</description></item><item><title>BigInt to Uint8Array</title><link>https://www.jackieli.dev/posts/bigint-to-uint8array/</link><pubDate>Thu, 23 Jul 2020 01:05:39 +0100</pubDate><guid>https://www.jackieli.dev/posts/bigint-to-uint8array/</guid><description>The problem came when I wanted to pass down BigDecimal&amp;rsquo;s unscaledBytes from kotlin/java to javascript through gRPC-Web.
Java&amp;rsquo;s implementation of the unscaledBytes returns signed big-endian bytes
Javascript has BigInt support, but lacks of toBytes(), stuff around the internet all seems to handle positive numbers just fine, but fails in negative number implementation
I borrowed from a Go implementation and adapted to javascript
Javascript implementation (using Typescript) const TWO_POWER_31 = 2147483648 const big0 = BigInt(0) const big1 = BigInt(1) const big8 = BigInt(8) export class BigDecimal { private big?</description></item></channel></rss>