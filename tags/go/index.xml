<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on jackieli.dev</title><link>https://jackieli.dev/tags/go/</link><description>Recent content in go on jackieli.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 13 May 2022 18:02:16 +0100</lastBuildDate><atom:link href="https://jackieli.dev/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Temporal is a Control Plane</title><link>https://jackieli.dev/posts/temporal-is-control-plane/</link><pubDate>Fri, 13 May 2022 18:02:16 +0100</pubDate><guid>https://jackieli.dev/posts/temporal-is-control-plane/</guid><description>Use Temporal as a control plane, not as a data plane - @maxim
Problem Link to heading In a typical ETL-like scenario, the data come as streams of rows. The workflow need to wait for a row to arrive and then kick off a series of processing steps synchronously or asynchronously. Example like:
From intuition, we might implement the workflow like this:
... sig := workflow.GetSignalChannel(ctx, &amp;#34;receiveRow&amp;#34;) // signal internally or externally to &amp;#34;receiveRow&amp;#34; channel for ctx.</description></item><item><title>Pointers in Go - used in sql.Scanner</title><link>https://jackieli.dev/posts/pointers-in-go-used-in-sql-scanner/</link><pubDate>Sat, 26 Jun 2021 12:40:10 +0100</pubDate><guid>https://jackieli.dev/posts/pointers-in-go-used-in-sql-scanner/</guid><description>Firstly a fun fact a lot people don&amp;rsquo;t know: when passing values between functions, it&amp;rsquo;s cheaper to pass values instead of pointers in Go. Reason is pointers to objects could be allocated on heap and it takes the computer more efforts to managed heap memory. While values are save on the stack, and stack is cheaper. For example, it&amp;rsquo;s preferable to:
type Foo struct { Bar string } func (f Foo) Echo() { println(f.</description></item><item><title>BigInt toBytes in different languages</title><link>https://jackieli.dev/posts/bigint-tobytes/</link><pubDate>Fri, 24 Jul 2020 11:00:17 +0100</pubDate><guid>https://jackieli.dev/posts/bigint-tobytes/</guid><description>Go &amp;amp; Javascript seems to be doing the same thing on BigInt: toBytes returns the absolute value with the sign seperately. While Java returns the Two&amp;rsquo;s complement representation. It makes it just a bit trickier to get the right binary representation.
This post explores ways to implement the Two&amp;rsquo;s complement representation in javascript &amp;amp; Go
javascript Link to heading $ node &amp;gt; BigInt(-257).toString(16) &amp;#39;-101&amp;#39; &amp;gt; BigInt(257).toString(16) &amp;#39;101&amp;#39; &amp;gt; It&amp;rsquo;s basically the sign plus the hex of the absolute value</description></item></channel></rss>