<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jackieli.dev</title><link>https://www.jackieli.dev/</link><description>Recent content on jackieli.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 17 Mar 2022 17:15:09 +0000</lastBuildDate><atom:link href="https://www.jackieli.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Use dynamic proto in cel-go</title><link>https://www.jackieli.dev/posts/use-dynamic-proto-in-cel-go/</link><pubDate>Thu, 17 Mar 2022 17:15:09 +0000</pubDate><guid>https://www.jackieli.dev/posts/use-dynamic-proto-in-cel-go/</guid><description>Cel-go is an amazing library for evaluating expressions. The extensive proto support just makes it better.
Let&amp;rsquo;s explore an interesting question: if we were to build a evaluation service without knowing the actual proto definitions, i.e. without bundling the generated code, how can we still evaluate the expressions that requests the fields of the proto? That is if we only have the bytes of the proto messages, but don&amp;rsquo;t have generated decoder, how do we evaluate.</description></item><item><title>Pointers in Go - used in sql.Scanner</title><link>https://www.jackieli.dev/posts/pointers-in-go-used-in-sql-scanner/</link><pubDate>Sat, 26 Jun 2021 12:40:10 +0100</pubDate><guid>https://www.jackieli.dev/posts/pointers-in-go-used-in-sql-scanner/</guid><description>Firstly a fun fact a lot people don&amp;rsquo;t know: when passing values between functions, it&amp;rsquo;s cheaper to pass values instead of pointers in Go. Reason is pointers to objects could be allocated on heap and it takes the computer more efforts to managed heap memory. While values are save on the stack, and stack is cheaper. For example, it&amp;rsquo;s preferable to:
type Foo struct { Bar string } func (f Foo) Echo() { println(f.</description></item><item><title>gRPC-Web interceptor</title><link>https://www.jackieli.dev/posts/grpc-web-interceptor/</link><pubDate>Sat, 01 Aug 2020 11:28:51 +0100</pubDate><guid>https://www.jackieli.dev/posts/grpc-web-interceptor/</guid><description>This was supposed to be 5 minute job, or at least it looked like it after I skimmed through the documentation
This was my first attempt:
class AuthInterceptor&amp;lt;REQ extends Request, RESP = any&amp;gt; { Intercept = class { private stream: grpcWeb.ClientReadableStream&amp;lt;RESP&amp;gt;; constructor(stream: grpcWeb.ClientReadableStream&amp;lt;RESP&amp;gt;) { this.stream = stream; } on&amp;lt;F extends Function&amp;gt;(eventType: EventType, callback: F) { if (eventType === &amp;#34;error&amp;#34;) { this.</description></item><item><title>Javascript Date</title><link>https://www.jackieli.dev/posts/javascript-date/</link><pubDate>Sat, 25 Jul 2020 23:29:55 +0100</pubDate><guid>https://www.jackieli.dev/posts/javascript-date/</guid><description>So I need a way to represent LocalDate that can be found in java.time package. Turns out it&amp;rsquo;s harder than it looks.
Take LocalDateTime for example: LocalDateTime is a relative date that&amp;rsquo;s the same no matter which time zone you&amp;rsquo;re in. The easiest thing is to just use string: 2020-07-25T01:02:03. Note that there is no zone/offset information in the string
But if you want to use a Date object in javascript to represent it, it gets very tricky.</description></item><item><title>BigInt toBytes in different languages</title><link>https://www.jackieli.dev/posts/bigint-tobytes/</link><pubDate>Fri, 24 Jul 2020 11:00:17 +0100</pubDate><guid>https://www.jackieli.dev/posts/bigint-tobytes/</guid><description>Go &amp;amp; Javascript seems to be doing the same thing on BigInt: toBytes returns the absolute value with the sign seperately. While Java returns the Two&amp;rsquo;s complement representation. It makes it just a bit trickier to get the right binary representation.
This post explores ways to implement the Two&amp;rsquo;s complement representation in javascript &amp;amp; Go
javascript $ node &amp;gt; BigInt(-257).toString(16) &amp;#39;-101&amp;#39; &amp;gt; BigInt(257).toString(16) &amp;#39;101&amp;#39; &amp;gt; It&amp;rsquo;s basically the sign plus the hex of the absolute value</description></item><item><title>BigInt to Uint8Array</title><link>https://www.jackieli.dev/posts/bigint-to-uint8array/</link><pubDate>Thu, 23 Jul 2020 01:05:39 +0100</pubDate><guid>https://www.jackieli.dev/posts/bigint-to-uint8array/</guid><description>The problem came when I wanted to pass down BigDecimal&amp;rsquo;s unscaledBytes from kotlin/java to javascript through gRPC-Web.
Java&amp;rsquo;s implementation of the unscaledBytes returns signed big-endian bytes
Javascript has BigInt support, but lacks of toBytes(), stuff around the internet all seems to handle positive numbers just fine, but fails in negative number implementation
I borrowed from a Go implementation and adapted to javascript
Javascript implementation (using Typescript) const TWO_POWER_31 = 2147483648 const big0 = BigInt(0) const big1 = BigInt(1) const big8 = BigInt(8) export class BigDecimal { private big?</description></item><item><title>About me</title><link>https://www.jackieli.dev/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.jackieli.dev/about/</guid><description>I&amp;rsquo;m a developer. I write Go, Kotlin and some javascrpt, typescript etc</description></item><item><title>Contact</title><link>https://www.jackieli.dev/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.jackieli.dev/contact/</guid><description>Hello to you too</description></item><item><title>Projects</title><link>https://www.jackieli.dev/projects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.jackieli.dev/projects/</guid><description>Nothing to see here&amp;hellip; Move along!</description></item></channel></rss>