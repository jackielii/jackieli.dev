<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on jackieli.dev</title><link>https://jackieli.dev/posts/</link><description>Recent content in Posts on jackieli.dev</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 04 May 2022 21:11:24 +0100</lastBuildDate><atom:link href="https://jackieli.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Temporal.io errGroup</title><link>https://jackieli.dev/posts/temporalio-errgroup/</link><pubDate>Wed, 04 May 2022 21:11:24 +0100</pubDate><guid>https://jackieli.dev/posts/temporalio-errgroup/</guid><description>Recently during develop a temporal workflow, I found I need an errGroup implementation - an easy way to synchronise the cancellation of all Temporal coroutines when one of them returned error. I adapted the x/sync/errgroup. Here is the code:
package main import ( &amp;#34;errors&amp;#34; &amp;#34;log&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; &amp;#34;go.temporal.io/sdk/testsuite&amp;#34; &amp;#34;go.temporal.io/sdk/workflow&amp;#34; ) func Workflow(ctx workflow.Context) (string, error) { g, cc := withErrGroup(ctx) for i := 0; i &amp;lt; 3; i++ { g.Go(cc, func(ctx workflow.</description></item><item><title>Vim jump to caps word on the same line</title><link>https://jackieli.dev/posts/vim-jump-to-caps/</link><pubDate>Sun, 01 May 2022 22:11:00 +0100</pubDate><guid>https://jackieli.dev/posts/vim-jump-to-caps/</guid><description>I often find myself wanting to jump to the word starting with capital letter on the same line. Especially in Go where the methods you import package always starts with capital letters. E.g.
&amp;lt;&amp;gt; fmt.Println(&amp;#34;Hello World&amp;#34;) When you cursor is at &amp;lt;&amp;gt; there are a few ways to quickly jump to Println:
press w three times (because there is a dot) press fP press l many times until you&amp;rsquo;re at P But it gets tricker when you have longer lines like this one:</description></item><item><title>GRPC &amp; GRPC-Web multiplexed in Istio</title><link>https://jackieli.dev/posts/grpc-web-istio/</link><pubDate>Fri, 25 Mar 2022 15:55:25 +0000</pubDate><guid>https://jackieli.dev/posts/grpc-web-istio/</guid><description>Envoy had grpc-web support ealy on. It&amp;rsquo;s used in the official grpc-web tutorial docs. In the envoy config of this tutorial, both grpc &amp;amp; grpcWeb are exposed via a single listener port. This is nice model when you have a production deployment in which some clients (mobile apps) want to speak to the GRPC protocol directly, but web apps want to go down to http/1.1 to work with browsers&amp;rsquo; xhr or fetch requests.</description></item><item><title>Use dynamic proto in cel-go</title><link>https://jackieli.dev/posts/use-dynamic-proto-in-cel-go/</link><pubDate>Thu, 17 Mar 2022 17:15:09 +0000</pubDate><guid>https://jackieli.dev/posts/use-dynamic-proto-in-cel-go/</guid><description>Cel-go is an amazing library for evaluating expressions. The extensive proto support just makes it better.
Let&amp;rsquo;s explore an interesting problem: if we were to build a evaluation service without embedding the actual proto, i.e. without bundling the generated code that defines the struct, fields etc, how can we still evaluate the expressions that requests the contents of the proto messages?
Let&amp;rsquo;s start with this proto:
syntax = &amp;#34;proto3&amp;#34;; package main; option go_package = &amp;#34;.</description></item><item><title>Pointers in Go - used in sql.Scanner</title><link>https://jackieli.dev/posts/pointers-in-go-used-in-sql-scanner/</link><pubDate>Sat, 26 Jun 2021 12:40:10 +0100</pubDate><guid>https://jackieli.dev/posts/pointers-in-go-used-in-sql-scanner/</guid><description>Firstly a fun fact a lot people don&amp;rsquo;t know: when passing values between functions, it&amp;rsquo;s cheaper to pass values instead of pointers in Go. Reason is pointers to objects could be allocated on heap and it takes the computer more efforts to managed heap memory. While values are save on the stack, and stack is cheaper. For example, it&amp;rsquo;s preferable to:
type Foo struct { Bar string } func (f Foo) Echo() { println(f.</description></item><item><title>gRPC-Web interceptor</title><link>https://jackieli.dev/posts/grpc-web-interceptor/</link><pubDate>Sat, 01 Aug 2020 11:28:51 +0100</pubDate><guid>https://jackieli.dev/posts/grpc-web-interceptor/</guid><description>This was supposed to be 5 minute job, or at least it looked like it after I skimmed through the documentation
This was my first attempt:
class AuthInterceptor&amp;lt;REQ extends Request, RESP = any&amp;gt; { Intercept = class { private stream: grpcWeb.ClientReadableStream&amp;lt;RESP&amp;gt;; constructor(stream: grpcWeb.ClientReadableStream&amp;lt;RESP&amp;gt;) { this.stream = stream; } on&amp;lt;F extends Function&amp;gt;(eventType: EventType, callback: F) { if (eventType === &amp;#34;error&amp;#34;) { this.stream.on(&amp;#34;error&amp;#34;, (err: grpcWeb.Error) =&amp;gt; { if (process.env.NODE_ENV === &amp;#34;development&amp;#34;) { console.</description></item><item><title>Javascript Date</title><link>https://jackieli.dev/posts/javascript-date/</link><pubDate>Sat, 25 Jul 2020 23:29:55 +0100</pubDate><guid>https://jackieli.dev/posts/javascript-date/</guid><description>So I need a way to represent LocalDate that can be found in java.time package. Turns out it&amp;rsquo;s harder than it looks.
Take LocalDateTime for example: LocalDateTime is a relative date that&amp;rsquo;s the same no matter which time zone you&amp;rsquo;re in. The easiest thing is to just use string: 2020-07-25T01:02:03. Note that there is no zone/offset information in the string
But if you want to use a Date object in javascript to represent it, it gets very tricky.</description></item><item><title>BigInt toBytes in different languages</title><link>https://jackieli.dev/posts/bigint-tobytes/</link><pubDate>Fri, 24 Jul 2020 11:00:17 +0100</pubDate><guid>https://jackieli.dev/posts/bigint-tobytes/</guid><description>Go &amp;amp; Javascript seems to be doing the same thing on BigInt: toBytes returns the absolute value with the sign seperately. While Java returns the Two&amp;rsquo;s complement representation. It makes it just a bit trickier to get the right binary representation.
This post explores ways to implement the Two&amp;rsquo;s complement representation in javascript &amp;amp; Go
javascript $ node &amp;gt; BigInt(-257).toString(16) &amp;#39;-101&amp;#39; &amp;gt; BigInt(257).toString(16) &amp;#39;101&amp;#39; &amp;gt; It&amp;rsquo;s basically the sign plus the hex of the absolute value</description></item><item><title>BigInt to Uint8Array</title><link>https://jackieli.dev/posts/bigint-to-uint8array/</link><pubDate>Thu, 23 Jul 2020 01:05:39 +0100</pubDate><guid>https://jackieli.dev/posts/bigint-to-uint8array/</guid><description>The problem came when I wanted to pass down BigDecimal&amp;rsquo;s unscaledBytes from kotlin/java to javascript through gRPC-Web.
Java&amp;rsquo;s implementation of the unscaledBytes returns signed big-endian bytes
Javascript has BigInt support, but lacks of toBytes(), stuff around the internet all seems to handle positive numbers just fine, but fails in negative number implementation
I borrowed from a Go implementation and adapted to javascript
Javascript implementation (using Typescript) const TWO_POWER_31 = 2147483648 const big0 = BigInt(0) const big1 = BigInt(1) const big8 = BigInt(8) export class BigDecimal { private big?</description></item></channel></rss>